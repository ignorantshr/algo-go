// 二叉树的存储——孩子兄弟表示法
// typedef struct CSNode {
//     ElemType data;                            // 数据域
//     struct CSNode *firstchild, *nextsibling;  // 第一个孩子和右兄弟指针
// } CSNode, *CSTree;

// 树的先根遍历
// 用孩子兄弟法来存储这棵树，就会发现 树的先根遍历序列 与这棵树相应
// 二叉树的先序序列 相同

// void PreOrder(TreeNode* R) {
//     if (R != NULL) {
//         visit(R);  // 访问根节点
//         while (R还有下一棵子树T) {
//             PreOrder(T);  // 先根遍历下一棵子树
//         }
//     }
// }

// 树的后根遍历
// 树的后根遍历序列 与这棵树相应 二叉树的中序序列 相同⚠️

// void PostOrder(TreeNode* R) {
//     if (R != NULL) {
//         while (R还有下一个子树T) {
//             PostOrder(T);  // 后根遍历下一棵子树
//         }
//         visit(R);  // 访问根节点
//     }
// }

// 森林是 m(m≥0) 棵互不相交的树的集合。

// 森林的先序遍历
// 法 1.等同于依次对各个树进行 先根遍历,最后排出完整的序列
// 法 2.先转化森林为对应的二叉树（孩子兄弟表示法），再对 二叉树进行先序遍历

// 森林的中序遍历⚠️
// 法 1.等同于依次对各个树进行 后根遍历,最后排出完整的序列
// 法 2.先转化森林为对应的二叉树（孩子兄弟表示法），再对 二叉树进行中序遍历

/* 总结⚠️

二叉树的存储——孩子兄弟表示法

树的先根遍历 == 二叉树的先序遍历
树的后根遍历 == 二叉树的中序遍历

森林的先序遍历 == 每颗树的先根遍历 == 二叉树的先序遍历
森林的中序遍历 == 每颗树的后根遍历 == 二叉树的中序遍历
 */
