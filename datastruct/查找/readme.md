[TOC]

查找算法的评价指标

- 查找长度——在查找运算中，需要对比关键字的次数称为查找长度

- 平均查找长度（ASL）——所有查找过程中进行关键字的比较次数的平均值。$ASL=\sum_{i=1}^{n}P_iC_i$ ，$P_i$ 为查找第 i 个元素的概率，$C_i$ 为查找第 i 个元素的查找长度，n 为数据元素个数。通常认为查找任何一个元素的概率都相同。ASL的数量级反应了查找算法的时间复杂度。

评价一个查找算法的效率时，通常考虑查找成功/查找失败两种情况的 ASL。

## 顺序查找
顺序查找，又叫“线性查找”，通常用于线性表
### 查找效率分析

- $ASL_{成功}=\frac{1+2+3+...+n}{n}=\frac{n+1}{2}$
- $ASL_{失败}=n+1$
- 平均时间复杂度为 O(n)

### 顺序查找的优化（对有序表）

对有序表来说，存在中途就查找失败的情况。
共有 n+1 个失败结点，即 n+1 种失败情况。
若假定出现这 n+1 个情况的概率都是相等的，则

$ASL_{失败}=\frac{1+2+3+...+n+n}{n+1}=\frac n2+\frac{n}{n+1}$ 

> 分子上最后面加了两个 n，因为最下面的两种失败情况都需要把最前面的 n个元素全部对比一遍，这两种情况都要对比 n次关键字

### 顺序查找的优化（被查概率不相等）

可以把被查概率更大的放在靠前位置，这样在查找成功的情况下，平均查找长度能够进一步缩短。当然这样因为关键字被打乱顺序，可能会导致查找失败时平均查找长度增加。因此要具体情况具体分析

## 折半查找
折半查找，又称“二分查找”，仅适用于有序的顺序表。只有顺序表才拥有随机访问的特性，链表没有。

折半查找的判定树中，只有最下面一层是不满的。因此，元素个数为n时树高$h=[log_2(n+1)]$（注：计算方法同“完全二叉树”）。树高直接反映了折半查找的时间复杂度，当然要注意到该树高不包含失败结点。失败结点：n+1个（等于成功结点的空链域数量）

### 折半查找的效率
不包含失败结点时，折半查找判定树树高$h=[log_2(n+1)]$。可推知查找成功和查找失败的 ASL 均 $≤h$。因此折半查找的时间复杂度为 $O(log_2n)$

注意这并不意味着折半查找一定比顺序查找快。

## 分块查找

又称“索引顺序查找”，数据分块存储，块内无序，块间有序。

索引表中记录每个分块的最大关键字、分块的区间；
先查索引表（顺序或折半），再对块内顺序查找。

### 折半查找查索引
> 若索引表中不包含目标关键字，则折半查找索引表最终停在 low > high，要在 low 所指分块中查找。

原因在于若折半查找失败，则最终 low>high。但在这之前的一步肯定是 low=high，这一步中 mid,low,high 肯定指向的是同一个位置。此时可能有两种情况，一种是 `mid<key`，这时我们会让 low后移一位，导致 low所指的元素一定比 mid 大。另一种是 `mid>key`，这时我们会让 high 后移一位， low不变。所以最终 low>high 的时候， low指针指向的位置的关键字一定大于目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字，我们只能在索引表的表项的值比目标关键值大的分块中进行查找才有可能找到。当然 low 最终可能超出索引表范围，此时说明查找失败。

若要求查找表是“动态查找表”，存储元素可以用链式存储而不是顺序存储

### 查找效率分析
分析查找成功时的效率需要套公式$ASL=\sum_{i=1}^{n}P_iC_i$。要分别老老实实算出所有元素关键字对比的次数，再分别乘以被查概率然后求和（查索引表的次数+块内查找次数）。查找失败的情况更复杂…一般不考。

!()[https://img-blog.csdnimg.cn/eef23b9c426847d9b05ea2d1500eeaec.png]

假设，长度为n的查找表的索引表和块内平均查找长度分别为$L_I,L_S$ ，则分块查找的平均查找长度为 $ASL=L_I+L_S$

用顺序查找查索引表，则 $L_I=\frac{(1+2+...+b)}{b}=\frac{b+1}{2}$ ，$L_S=\frac{1+2+...+s}{s}=\frac{s+1}{2}$
<br>
则 $ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}$ (因为 $b=n/s$)，当$s=\sqrt n$时，$ASL_{最小}=\sqrt n+1$

用折半查找查索引表，则 $L_I=[log_2(b+1)]$，$L_S=\frac{1+2+...+s}{s}=\frac{s+1}{2}$
<br>
则 $ASL=[log_2(b+1)]+\frac{s+1}{2}$

## 二叉排序树
二叉排序树，又称二叉查找树（BST）。一棵二叉排序树或者是空二叉树，或者是具有如下性质的二叉树：

- 左子树上所有结点的关键字均小于根结点的关键字
- 右子树上所有结点的关键字均大于根结点的关键字

### 查找效率分析

平均查找长度的数量级就是查找操作的时间复杂度，我们要追求查找操作的时间复杂度尽可能地低，因为插入和删除都需要建立在查找基础上。

若树高 h ，找到最下层的一个结点需要对比 h 次。

最好情况： n 个结点的二叉树最小高度为$[log_2n]+1$。平均查找长度=$O(log_2n)$

最坏情况：每个结点只有一个分支，树高 h =结点数 n 。平均查找长度=$O(n)$