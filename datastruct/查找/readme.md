[TOC]

查找算法的评价指标

- 查找长度——在查找运算中，需要对比关键字的次数称为查找长度

- 平均查找长度（ASL）——所有查找过程中进行关键字的比较次数的平均值。$ASL=\sum_{i=1}^{n}P_iC_i$ ，$P_i$ 为查找第 i 个元素的概率，$C_i$ 为查找第 i 个元素的查找长度，n 为数据元素个数。通常认为查找任何一个元素的概率都相同。ASL的数量级反应了查找算法的时间复杂度。

评价一个查找算法的效率时，通常考虑查找成功/查找失败两种情况的 ASL。

## 顺序查找
顺序查找，又叫“线性查找”，通常用于线性表
### 查找效率分析

- $ASL_{成功}=\frac{1+2+3+...+n}{n}=\frac{n+1}{2}$
- $ASL_{失败}=n+1$
- 平均时间复杂度为 O(n)

### 顺序查找的优化（对有序表）

对有序表来说，存在中途就查找失败的情况。
共有 n+1 个失败结点，即 n+1 种失败情况。
若假定出现这 n+1 个情况的概率都是相等的，则

$ASL_{失败}=\frac{1+2+3+...+n+n}{n+1}=\frac n2+\frac{n}{n+1}$ 

> 分子上最后面加了两个 n，因为最下面的两种失败情况都需要把最前面的 n个元素全部对比一遍，这两种情况都要对比 n次关键字

### 顺序查找的优化（被查概率不相等）

可以把被查概率更大的放在靠前位置，这样在查找成功的情况下，平均查找长度能够进一步缩短。当然这样因为关键字被打乱顺序，可能会导致查找失败时平均查找长度增加。因此要具体情况具体分析

## 折半查找
折半查找，又称“二分查找”，仅适用于有序的顺序表。只有顺序表才拥有随机访问的特性，链表没有。

折半查找的判定树中，只有最下面一层是不满的。因此，元素个数为n时树高$h=[log_2(n+1)]$（注：计算方法同“完全二叉树”）。树高直接反映了折半查找的时间复杂度，当然要注意到该树高不包含失败结点。失败结点：n+1个（等于成功结点的空链域数量）

### 折半查找的效率
不包含失败结点时，折半查找判定树树高$h=[log_2(n+1)]$。可推知查找成功和查找失败的 ASL 均 $≤h$。因此折半查找的时间复杂度为 $O(log_2n)$

注意这并不意味着折半查找一定比顺序查找快。

## 分块查找

又称“索引顺序查找”，数据分块存储，块内无序，块间有序。

索引表中记录每个分块的最大关键字、分块的区间；
先查索引表（顺序或折半），再对块内顺序查找。

### 折半查找查索引
> 若索引表中不包含目标关键字，则折半查找索引表最终停在 low > high，要在 low 所指分块中查找。

原因在于若折半查找失败，则最终 low>high。但在这之前的一步肯定是 low=high，这一步中 mid,low,high 肯定指向的是同一个位置。此时可能有两种情况，一种是 `mid<key`，这时我们会让 low后移一位，导致 low所指的元素一定比 mid 大。另一种是 `mid>key`，这时我们会让 high 后移一位， low不变。所以最终 low>high 的时候， low指针指向的位置的关键字一定大于目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字，我们只能在索引表的表项的值比目标关键值大的分块中进行查找才有可能找到。当然 low 最终可能超出索引表范围，此时说明查找失败。

若要求查找表是“动态查找表”，存储元素可以用链式存储而不是顺序存储

### 查找效率分析
分析查找成功时的效率需要套公式$ASL=\sum_{i=1}^{n}P_iC_i$。要分别老老实实算出所有元素关键字对比的次数，再分别乘以被查概率然后求和（查索引表的次数+块内查找次数）。查找失败的情况更复杂…一般不考。

!()[https://img-blog.csdnimg.cn/eef23b9c426847d9b05ea2d1500eeaec.png]

假设，长度为n的查找表的索引表和块内平均查找长度分别为$L_I,L_S$ ，则分块查找的平均查找长度为 $ASL=L_I+L_S$

用顺序查找查索引表，则 $L_I=\frac{(1+2+...+b)}{b}=\frac{b+1}{2}$ ，$L_S=\frac{1+2+...+s}{s}=\frac{s+1}{2}$
<br>
则 $ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}$ (因为 $b=n/s$)，当$s=\sqrt n$时，$ASL_{最小}=\sqrt n+1$

用折半查找查索引表，则 $L_I=[log_2(b+1)]$，$L_S=\frac{1+2+...+s}{s}=\frac{s+1}{2}$
<br>
则 $ASL=[log_2(b+1)]+\frac{s+1}{2}$

## 二叉排序树
二叉排序树，又称二叉查找树（BST）。一棵二叉排序树或者是空二叉树，或者是具有如下性质的二叉树：

- 左子树上所有结点的关键字均小于根结点的关键字
- 右子树上所有结点的关键字均大于根结点的关键字

### 查找效率分析

平均查找长度的数量级就是查找操作的时间复杂度，我们要追求查找操作的时间复杂度尽可能地低，因为插入和删除都需要建立在查找基础上。

若树高 h ，找到最下层的一个结点需要对比 h 次。

最好情况： n 个结点的二叉树最小高度为$[log_2n]+1$。平均查找长度=$O(log_2n)$

最坏情况：每个结点只有一个分支，树高 h =结点数 n 。平均查找长度=$O(n)$

## 平衡二叉树

平衡二叉树（Balanced Binary Tree）简称平衡树（AVL树）:树上任一结点的左子树和右子树高度之差不超过1

结点的平衡因子=左子树高-右子树高。显然平衡二叉树结点的平衡因子的值只可能是-1，0，1。只要有任一结点的平衡因子绝对值大于1，就不是平衡二叉树

### 查找效率分析

若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过$O(h)$

平衡二叉树——树上任一结点的左子树和右子树的高度之差不超过1

假设以$n_h$表示深度为h的平衡树中含有的最少结点数

则有$n_0=0,n_1=1,n_2=2$，并且有$n_h=n_{h-1}+n_{h-2}+1$可以用数学证明含有 n 个结点的平衡二叉树的最大深度为$O(log_2n)$，平衡二叉树的平均查找长度为$O(log_2n)$

## 红黑树

### 概念

- 黑高：一个结点的“黑高”：从某结点出发（不含自身）到达任一空叶结点的路径上黑结点的数量
- 叶结点：在红黑树中，“叶结点”通常指“失败结点”（空叶结点/NULL 结点/外部结点）

### 定义

- 左根右：RBT 是一种 BST，满足 左<=根<=右
- 根叶黑：根节点、叶结点一定是黑色
- 不红红：任何一条查找路径上不能连续出现两个红结点
- 黑路同：从任一结点出发，到达任一空结点的路径上经过的黑结点数量都相同

根节点黑高为 h 的红黑树，内部结点数（关键字）至少有多少个？至多有多少个?

- 内部结点数最少的情况 —— 总共 h 层黑结点的满树形态
- 内部结点数最多的情况 —— h 层黑结点，每一层黑结点下面都铺满一层红结点。共 2h 层的满树形态

故若根节点黑高为 h，内部结点数（关键字）最少有$2^h-1$个，最多有$2^{2h}-1$个。
### 性质

1. 从根结点到叶结点的最长路径不大于最短路径的 2 倍，任一结点的左右子树高度之差不会超过2倍（由 ”不红红“ 和 ”黑路同“ 推得）
1. 有 n 个内部结点的红黑树高度 $h \le 2log_2(n+1)$，红黑树查找操作时间复杂度= $O(log_2n)$，查找效率与AVL树同等数量级

性质1证明：任何一条查找失败路径上黑结点数量都相同，而路径上不能连续出现两个红结点，即红结点只能穿插在各个黑结点中间

性质2证明：若红黑树总高度 h，则根节点黑高$\ge h/2$，因此内部结点数$n\ge 2^{h/2}-1$，由此推出h$h \le 2log_2(n+1)$

### 查找
与BST、AVL相同，从根出发，左小右大，若查找到一个空叶节点，则查找失败。

### 插入

- 新结点为根染黑
- 非根染红，若插入后违反“不红红”，则看叔叔的脸色
    - 红叔叔：染色+变新。
        - 叔、父、爷 变色，爷变新。
            > 父、叔一定是红结点，爷一定是黑结点。变色后爷变成新结点（变红），然后继续判断爷是否满足条件，不满足条件则继续调整
    - 黑叔叔：旋转+染色
        - LL：爷右旋，父换爷+两者变色。
            > 父红爷黑，右旋后的格局是`儿[红]<父[红]<爷[黑]`，两者变色即可满足条件
        - RR：爷左旋，父换爷+两者变色。
            > 父红爷黑，左旋后的格局是`爷[黑]<父[红]<儿[红]`，两者变色即可满足条件
        - LR：左、右双旋，儿换爷+染色。
            > 父左旋把儿换上去，爷右旋再次把儿换上去，现在的格局是`父[红]<儿[红]<爷[黑]`，最后让原来的儿和爷变色
        - RL：右、左双旋，儿换爷+染色。
            > 父右旋把儿换上去，爷左旋再次把儿换上去，现在的格局是`爷[黑]<儿[红]<父[红]`，最后让原来的儿和爷变色
### 红黑树的删除

1.红黑树删除操作的时间复杂度 = $O(log_2n)$
2.在红黑树中删除结点的处理方式和 “二叉排序树的删除” 一样
3.按2删除结点后，可能破坏 “红黑树特性”，此时需要调整结点颜色、位置，使其再次满足 “红黑树特性”。

## 多叉查找树

```c
//5叉排序树的结点定义
struct Node {
    ElemType keys[4];       //最多4个关键字
    struct Node * child[5]; //最多5个孩子
    int num;         //结点中有几个关键字
}
```

1. m 叉查找树中，规定除了根节点外，任何结点至少有 [m/2]（向上取整） 个分叉，即至少含有 [m/2]-1 个关键字。
    > eg：对于5叉排序树，规定除了根节点外，任何结点都至少有3个分叉，2个关键字
2. m 叉查找树中，规定对于任何一个结点，其所有子树的高度都要相同。
3. 结点内关键字有序

## B树

B树，又称`多路平衡查找树`，B树中所有结点的孩子个数的**最大值**称为B树的阶，通常用 m 表示。一棵 m 阶B树或为空树，或为满足如下特性的 m 叉树：

1. 树中每个结点至多有 m 棵子树，即至多含有 m-1 个关键字。
2. 若根结点不是终端结点，则至少有两棵子树。
3. 除根结点外的所有非叶结点至少有 [m/2] （向上取整）棵子树，即至少含有 [m/2]-1 个关键 字。
4. 所有非叶结点的结构如下：

$| n | P_0 | K_1 | P_1 | K_2 | P_2 | … | K_n | P_n |$

其中，$K_i(i=1,2,...,n)$ 为结点的关键字，且满足 $K_1\lt K_2\lt ...\lt K_n$ ；$P_i(i=0,1,...,n)$ 为指向子树根结点的指针，且指针 $P_{i-1}$ 所指子树中所有结点的关键字均小于$K_i$ ，$P_i$ 所指子树中所有结点的关键字均大于$K_i$ ，$n([m/2]-1\le n \le m-1)$为结点中关键字的个数。

5. 所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。
!()[https://img-blog.csdnimg.cn/cba9b22161764ba8aa972e23cf0ea354.png]

### B树核心特性

1.根节点的$子树数 \in [2,m]$，$关键字数[1,m-1]$。其它结点的$子树数 \in [[m/2],m]$；$关键字 \in [[m/2]-1,m-1]$

2.对任一结点，其所有子树高度都相同

3.关键字的值：$子树0 \lt 关键字1 \lt 子树1 \lt 关键字2 \lt 子树2 \lt … $（类比二叉查找树 $左 \lt 中 \lt 右$）

### B树的高度

含 n 个关键字的 m 阶B树，最小高度、最大高度:
> $log_m(n+1) ≤ h ≤ log_{[m/2]}(\frac{n+1}{2})+1$

最小高度 —— 让每个结点都尽可能地填满 m-1 个关键字，m 个分叉，则 
> $n \le (m-1)(1+m+m^2+…+m^(h-1) = m^h-1)$

因此 $h \ge log_m(n+1)$

最大高度 —— 让各层的分叉尽可能的少，即根节点只有2个分叉，其他结点只有 [m/2] 个分叉
各层结点至少有：第一层1、第二层2、第三层 $2[m/2]$ … 第 h 层 $2([m/2])^{h-2}$，第 $h+1$ 层共有叶子结点（失败结点）$2([m/2]^{h-1})$个。

n 个关键字将数域切分为 n+1 个区间，对应 n+1 种失败情况，这些失败情况都会体现在叶子结点当中，所以 n 个关键字的B树必有 n+1 个叶子结点，则 $n+1\ge 2([m/2])^{h-1}$ 。

即 $ h\le log_{[m/2]}\frac{n+1}{2}+1$

或者从另外一个角度出发，让每个结点包含的关键字、分叉尽可能少。记 k=[m/2] :

|  |最少结点数|最少关键字数|
|:---|:---|:---|
|第1层|  1 |  1  |
|第2层| 2  |  2(k-1)  |
|第3层| 2k  | 2k(k-1)  |
|第4层| $2k^2$  | $2k^2(k-1)$|
|...|...|...|
|第h层| $2k^{h-2}$ | $2k^{h-2}(k-1)$|

这里面的 2 是因为根结点最少有两个子树。

h层的 m 阶B树至少包含关键字总数 $1+2(k-1)(k^0+k^1+k^2+...+k^{h-2})=1+2(k^{h-1}-1)$ 若关键字总数少于这个值，则高度一定小于 h。因此 $n\ge 1+2(k^{h-1}-1)$

得，$h\le log_k\frac{n+1}{2}+1=log_{[m/2]}\frac{n+1}{2}+1$

### B树的插入
新元素一定是插入到最底层 ”终端节点“，用 ”查找“ 来确定插入位置。

在插入 key 后，若导致原结点关键字数超过上限，则从中间位置（ [m/2] ，向上取整）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放在新结点中，中间位置（ [m/2] ）的结点插入父结点中 **指向原结点的指针右边的位置**。若此时导致其父结点的关键点个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增 1。

### B树的删除
可以看这篇(文章)[https://www.cnblogs.com/nullzx/p/8729425.html]，写的比较容易懂。

对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作。
若被删除关键字在非终端节点，则用直接前驱或直接后继来替代被删除的关键字。

直接前驱：当前关键字左侧指针所指子树中”最右下“的元素
直接后继：当前关键字右侧指针所指子树中”最左下“的元素

若被删除关键字在终端节点，则直接删除该关键字（要注意节点关键字个数是否低于下限 [m/2]-1:
- 兄弟够借。若被删除关键字所在结点删除前的关键字个数低于下限（TODO，为什么是删除前而不是删除后），且与此结点右（或左）兄弟结点的关键字个数还很宽裕，则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法）。即
    - 当右兄弟很宽裕时，用当前结点的后继、后继的后继来填补空缺。
    - 当左兄弟很宽裕时，用当前结点的前驱、前驱的前驱来填补空缺
- 兄弟不够借。若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均 = [m/2]-1，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。

在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0（根结点关键字个数为1时，有2棵子树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点。且关键字个数减少到 [m/2]-2，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止。

## B+树

一棵 m 阶的B+树需满足下列条件：

1. 每个分支结点最多有 m 棵子树（孩子结点），最多有 m 个关键字。
2. `非叶根结点`至少有两棵子树，其他每个分支结点至少有 [m/2] 棵子树。
3. 结点的子树个数与关键字个数相等。
4. 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来支持顺序查找。
5. 所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针。

### B+树的查找
B+树同时支持多路查找和顺序查找。

B树查找成功，可能停在任何一层。B+树中，如果只是在分支结点找到要查找的关键字，查找并没有结束，只有找到最下层的叶子结点后才可以找到某一个关键字实际对应的记录的存放位置。无论查找成功与否，最终一定都要走到最下面一层结点。

## B+树 vs B树

!(B树 B+树 对比)[https://img-blog.csdnimg.cn/img_convert/0d4e6d8a6a11f95d284aad38e15cd56d.png]

m 阶B树：

1. 结点中的 n 个关键字对应 n+1 棵子树
2. 根节点的关键字数 $n\in [1,m-1]$，其他结点的关键字数 $n\in [[m/2]-1, m-1]$
3. 在B树中，各结点中包含的关键字是不重复的
4. B树的结点中都包含了关键字对应的记录的存储地址

m 阶B+树：

1. 结点中的 n 个关键字对应 n 棵子树
2. 根节点的关键字数 $n\in [1,m]$ ，其他结点的关键字数 $n\in [[m/2], m]$
3. 在B+树中，叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中
4. 在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。

在B+树中，非叶结点不含有该关键字对应记录的存储地址。可以使一个磁盘块可以包含更多个关键字，使得B+树的阶更大，树高更矮，读磁盘次数更少，查找更快。典型应用：关系数据库的“索引”（如MySQL）。