[TOC]

查找算法的评价指标

- 查找长度——在查找运算中，需要对比关键字的次数称为查找长度

- 平均查找长度（ASL）——所有查找过程中进行关键字的比较次数的平均值。$ASL=\sum_{i=1}^{n}P_iC_i$ ，$P_i$ 为查找第 i 个元素的概率，$C_i$ 为查找第 i 个元素的查找长度，n 为数据元素个数。通常认为查找任何一个元素的概率都相同。ASL的数量级反应了查找算法的时间复杂度。

评价一个查找算法的效率时，通常考虑查找成功/查找失败两种情况的 ASL。

## 顺序查找
顺序查找，又叫“线性查找”，通常用于线性表
### 查找效率分析

- $ASL_{成功}=\frac{1+2+3+...+n}{n}=\frac{n+1}{2}$
- $ASL_{失败}=n+1$
- 平均时间复杂度为 O(n)

### 顺序查找的优化（对有序表）

对有序表来说，存在中途就查找失败的情况。
共有 n+1 个失败结点，即 n+1 种失败情况。
若假定出现这 n+1 个情况的概率都是相等的，则

$ASL_{失败}=\frac{1+2+3+...+n+n}{n+1}=\frac n2+\frac{n}{n+1}$ 

> 分子上最后面加了两个 n，因为最下面的两种失败情况都需要把最前面的 n个元素全部对比一遍，这两种情况都要对比 n次关键字

### 顺序查找的优化（被查概率不相等）

可以把被查概率更大的放在靠前位置，这样在查找成功的情况下，平均查找长度能够进一步缩短。当然这样因为关键字被打乱顺序，可能会导致查找失败时平均查找长度增加。因此要具体情况具体分析

## 折半查找
折半查找，又称“二分查找”，仅适用于有序的顺序表。只有顺序表才拥有随机访问的特性，链表没有。

折半查找的判定树中，只有最下面一层是不满的。因此，元素个数为n时树高$h=[log_2(n+1)]$（注：计算方法同“完全二叉树”）。树高直接反映了折半查找的时间复杂度，当然要注意到该树高不包含失败结点。失败结点：n+1个（等于成功结点的空链域数量）

### 折半查找的效率
不包含失败结点时，折半查找判定树树高$h=[log_2(n+1)]$。可推知查找成功和查找失败的 ASL 均 $≤h$。因此折半查找的时间复杂度为 $O(log_2n)$

注意这并不意味着折半查找一定比顺序查找快。

## 分块查找

又称“索引顺序查找”，数据分块存储，块内无序，块间有序。

索引表中记录每个分块的最大关键字、分块的区间；
先查索引表（顺序或折半），再对块内顺序查找。

### 折半查找查索引
> 若索引表中不包含目标关键字，则折半查找索引表最终停在 low > high，要在 low 所指分块中查找。

原因在于若折半查找失败，则最终 low>high。但在这之前的一步肯定是 low=high，这一步中 mid,low,high 肯定指向的是同一个位置。此时可能有两种情况，一种是 `mid<key`，这时我们会让 low后移一位，导致 low所指的元素一定比 mid 大。另一种是 `mid>key`，这时我们会让 high 后移一位， low不变。所以最终 low>high 的时候， low指针指向的位置的关键字一定大于目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字，我们只能在索引表的表项的值比目标关键值大的分块中进行查找才有可能找到。当然 low 最终可能超出索引表范围，此时说明查找失败。

若要求查找表是“动态查找表”，存储元素可以用链式存储而不是顺序存储

### 查找效率分析
分析查找成功时的效率需要套公式$ASL=\sum_{i=1}^{n}P_iC_i$。要分别老老实实算出所有元素关键字对比的次数，再分别乘以被查概率然后求和（查索引表的次数+块内查找次数）。查找失败的情况更复杂…一般不考。

!()[https://img-blog.csdnimg.cn/eef23b9c426847d9b05ea2d1500eeaec.png]

假设，长度为n的查找表的索引表和块内平均查找长度分别为$L_I,L_S$ ，则分块查找的平均查找长度为 $ASL=L_I+L_S$

用顺序查找查索引表，则 $L_I=\frac{(1+2+...+b)}{b}=\frac{b+1}{2}$ ，$L_S=\frac{1+2+...+s}{s}=\frac{s+1}{2}$
<br>
则 $ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}$ (因为 $b=n/s$)，当$s=\sqrt n$时，$ASL_{最小}=\sqrt n+1$

用折半查找查索引表，则 $L_I=[log_2(b+1)]$，$L_S=\frac{1+2+...+s}{s}=\frac{s+1}{2}$
<br>
则 $ASL=[log_2(b+1)]+\frac{s+1}{2}$

## 二叉排序树
二叉排序树，又称二叉查找树（BST）。一棵二叉排序树或者是空二叉树，或者是具有如下性质的二叉树：

- 左子树上所有结点的关键字均小于根结点的关键字
- 右子树上所有结点的关键字均大于根结点的关键字

### 查找效率分析

平均查找长度的数量级就是查找操作的时间复杂度，我们要追求查找操作的时间复杂度尽可能地低，因为插入和删除都需要建立在查找基础上。

若树高 h ，找到最下层的一个结点需要对比 h 次。

最好情况： n 个结点的二叉树最小高度为$[log_2n]+1$。平均查找长度=$O(log_2n)$

最坏情况：每个结点只有一个分支，树高 h =结点数 n 。平均查找长度=$O(n)$

## 平衡二叉树

平衡二叉树（Balanced Binary Tree）简称平衡树（AVL树）:树上任一结点的左子树和右子树高度之差不超过1

结点的平衡因子=左子树高-右子树高。显然平衡二叉树结点的平衡因子的值只可能是-1，0，1。只要有任一结点的平衡因子绝对值大于1，就不是平衡二叉树

### 查找效率分析

若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过$O(h)$

平衡二叉树——树上任一结点的左子树和右子树的高度之差不超过1

假设以$n_h$表示深度为h的平衡树中含有的最少结点数

则有$n_0=0,n_1=1,n_2=2$，并且有$n_h=n_{h-1}+n_{h-2}+1$可以用数学证明含有 n 个结点的平衡二叉树的最大深度为$O(log_2n)$，平衡二叉树的平均查找长度为$O(log_2n)$

## 红黑树

### 概念

- 黑高：一个结点的“黑高”：从某结点出发（不含自身）到达任一空叶结点的路径上黑结点的数量
- 叶结点：在红黑树中，“叶结点”通常指“失败结点”（空叶结点/NULL 结点/外部结点）

### 定义

- 左根右：RBT 是一种 BST，满足 左<=根<=右
- 根叶黑：根节点、叶结点一定是黑色
- 不红红：任何一条查找路径上不能连续出现两个红结点
- 黑路同：从任一结点出发，到达任一空结点的路径上经过的黑结点数量都相同

根节点黑高为 h 的红黑树，内部结点数（关键字）至少有多少个？至多有多少个?

- 内部结点数最少的情况 —— 总共 h 层黑结点的满树形态
- 内部结点数最多的情况 —— h 层黑结点，每一层黑结点下面都铺满一层红结点。共 2h 层的满树形态

故若根节点黑高为 h，内部结点数（关键字）最少有$2^h-1$个，最多有$2^{2h}-1$个。
### 性质

1. 从根结点到叶结点的最长路径不大于最短路径的 2 倍，任一结点的左右子树高度之差不会超过2倍（由 ”不红红“ 和 ”黑路同“ 推得）
1. 有 n 个内部结点的红黑树高度 $h \le 2log_2(n+1)$，红黑树查找操作时间复杂度= $O(log_2n)$，查找效率与AVL树同等数量级

性质1证明：任何一条查找失败路径上黑结点数量都相同，而路径上不能连续出现两个红结点，即红结点只能穿插在各个黑结点中间

性质2证明：若红黑树总高度 h，则根节点黑高$\ge h/2$，因此内部结点数$n\ge 2^{h/2}-1$，由此推出h$h \le 2log_2(n+1)$

### 查找
与BST、AVL相同，从根出发，左小右大，若查找到一个空叶节点，则查找失败。

### 插入

- 新结点为根染黑
- 非根染红，若插入后违反“不红红”，则看叔叔的脸色
    - 红叔叔：染色+变新。
        - 叔、父、爷 变色，爷变新。
            > 父、叔一定是红结点，爷一定是黑结点。变色后爷变成新结点（变红），然后继续判断爷是否满足条件，不满足条件则继续调整
    - 黑叔叔：旋转+染色
        - LL：爷右旋，父换爷+两者变色。
            > 父红爷黑，右旋后的格局是`儿[红]<父[红]<爷[黑]`，两者变色即可满足条件
        - RR：爷左旋，父换爷+两者变色。
            > 父红爷黑，左旋后的格局是`爷[黑]<父[红]<儿[红]`，两者变色即可满足条件
        - LR：左、右双旋，儿换爷+染色。
            > 父左旋把儿换上去，爷右旋再次把儿换上去，现在的格局是`父[红]<儿[红]<爷[黑]`，最后让原来的儿和爷变色
        - RL：右、左双旋，儿换爷+染色。
            > 父右旋把儿换上去，爷左旋再次把儿换上去，现在的格局是`爷[黑]<儿[红]<父[红]`，最后让原来的儿和爷变色
### 红黑树的删除

1.红黑树删除操作的时间复杂度 = $O(log_2n)$
2.在红黑树中删除结点的处理方式和 “二叉排序树的删除” 一样
3.按2删除结点后，可能破坏 “红黑树特性”，此时需要调整结点颜色、位置，使其再次满足 “红黑树特性”。
